(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{279:function(n,e,t){"use strict";t.r(e);var m=t(0),i=Object(m.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("/*")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("Definition for singly-linked list.")])]),n._v(" "),t("li",[t("p",[n._v("struct ListNode {")])]),n._v(" "),t("li",[t("pre",[t("code",[n._v("int val;\n")])])]),n._v(" "),t("li",[t("pre",[t("code",[n._v("ListNode *next;\n")])])]),n._v(" "),t("li",[t("pre",[t("code",[n._v("ListNode(int x) : val(x), next(NULL) {}\n")])])]),n._v(" "),t("li",[t("p",[n._v("};\n*/\nclass Solution {\npublic:\nListNode* reverseBetween(ListNode* head, int m, int n) {\n//先考虑边界情况，即不需要变换指针的情况\n//如果head 或者head->next为空，或者m==n 返回head\nif(head == NULL || head->next == NULL || m==n)\n{\nreturn head;\n}\n//要更改的指针：m-1.next =n;m.next = n.next;m+1~n:m+k.next = m+k-1.next\n//如果m==1，head指针有变化，否则无变化\n//遍历链表，先找到第m-1个元素，由于遍历到后面需要第m-1和第m个元素，所以需要先保存一下\n//如果m==1，第m-1个元素就为空\nListNode *m_1 = head;\nListNode *mm = head;\nListNode *pre = head;\nListNode *hc = head;\nint count =1;\n//先确定第m-1个元素\nif(m == 1)\n{\nm_1 = nullptr;"),t("br"),n._v("\nmm = head;\n}\nelse\n{\n//先找到第m-1个元素\nwhile(count <m-1 && hc)\n{\nhc = hc->next;\n++count;\n}\n//此时hc为第m-1个元素\nm_1 = hc;\nmm = hc->next;//记录第m个元素\n}\n//从第m+1个元素开始，要变换m+1~n元素的next指针\npre = mm;\nhc = mm->next; //此时hc指向第m+1个元素\ncount = m+1;\nwhile(count <n+1 &&hc)\n{\nListNode *tmp = hc->next;\nhc->next = pre;\npre = hc;\nhc = tmp;\n++count;\n}\n//当count == n+1时，pre指向第n个元素，hc指向第n+1个元素\n//先确定头指针要不要变\nif(m == 1) head = pre;\nelse\nm_1->next = pre;\nmm->next = hc;\nreturn head;")]),n._v(" "),t("p",[n._v("}\n};")])])])])},[],!1,null,null,null);e.default=i.exports}}]);