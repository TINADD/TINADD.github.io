(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{302:function($,v,_){"use strict";_.r(v);var n=_(0),t=Object(n.a)({},function(){var $=this,v=$.$createElement,_=$._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":$.$parent.slotKey}},[_("p",[$._v("一些应用涉及将"),_("strong",[$._v("n个不同的元素")]),$._v("分成"),_("strong",[$._v("一组不相交的集合")]),$._v("，")]),$._v(" "),_("p",[$._v("这些应用经常涉及两个操作：寻找给定元素的唯一集合、合并两个集合")]),$._v(" "),_("h2",{attrs:{id:"不相交集合的操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不相交集合的操作","aria-hidden":"true"}},[$._v("#")]),$._v(" 不相交集合的操作")]),$._v(" "),_("p",[$._v("一个"),_("strong",[$._v("不相交集合数据结构")]),$._v("（disjoint-set data structure）维护了一个不相交动态的集合$S = {S_1,S_2,...,S_3}$。每个集合都有一个元素作为该集合的"),_("strong",[$._v("代表")]),$._v("来标识该集合。")]),$._v(" "),_("p",[$._v("这里用一个对象表示集合中的每个元素。设$x$表示一个对象，则该数据结构应该支持以下三个操作：")]),$._v(" "),_("p",[$._v("$MAKE-SET(x)😒 建立一个新的"),_("strong",[$._v("集合")]),$._v("， 它的唯一成员（所以也是代表）为$x$ 。因为各个集合是不相交的，所以$x$不会出现在别的集合中。")]),$._v(" "),_("p",[$._v("$UNION(x,y):$将包含$x$和$y$的两个动态集合（表示为$S_x$和$S_y$）合并成为一个新的集合。虽然$UNION$的很多实现中特别选择$S_x$或$S_y$的代表作为新的代表，但是结果集的代表可以是并集中的任何一个元素。在合并时，常规操作是 把"),_("strong",[$._v("其中一个集合的元素放入另一个集合中")]),$._v("。")]),$._v(" "),_("p",[$._v("$FIND-SET(x):$返回一个指针，这个指针指向包含$x$的集合的代表。")]),$._v(" "),_("p",[$._v("这里用两个参数$n、m$来分析不相交集合数据结构的运行时间，假设$n$个$MAKE-SET$操作总是最先执行的n个操作：$n$表示$MAKE-SET$的操作次数；$m$表示$MAKE-SET、UNION、FIND-SET$操作的总次数。")]),$._v(" "),_("h3",{attrs:{id:"应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用","aria-hidden":"true"}},[$._v("#")]),$._v(" 应用")]),$._v(" "),_("p",[$._v("不相交集合数据结构的应用之一就是：确定无向图的连通分量。\nps. 在计算连通分量的算法实现中，图和不相交集数据结构的表示需要相互引用。图中的每个顶点都应包含一个指向与之对应的不相交集合对象的指针；反之亦然。\n//使用不相交集合操作来计算一个图的连通分量\nCONNECTED-COMPONENTS(G)\nfor each vertex v ∈G.V\nMAKE-SET(V)\nfor each edge(u,v)∈G.E\nif FIND-SET(u) \\neq FIND-SET(v)\nUNION(u,v)")]),$._v(" "),_("p",[$._v("//判断两个顶点是否在同一个连通分量\nSAME-COMPONENT(u,v)\nif FIND-SET(u) \\eq FIND-SET(v)\nreturn TRUE\nelse return FALSE")]),$._v(" "),_("h2",{attrs:{id:"不相交集合的链表表示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不相交集合的链表表示","aria-hidden":"true"}},[$._v("#")]),$._v(" 不相交集合的链表表示")]),$._v(" "),_("p",[$._v("每个集合用一个自己的链表来表示。每个集合的对象包含$head$属性和$tail$属性，链表中的每个对象都包含一个"),_("strong",[$._v("集合成员")]),$._v("（结点）、一个指向链表中"),_("strong",[$._v("下一个对象的指针和")]),$._v("一个"),_("strong",[$._v("指回到集合对象的指针")]),$._v("。")]),$._v(" "),_("p",[$._v("在每个链表中，对象的顺序任意。代表是链表中第一个对象的集合成员。")]),$._v(" "),_("p",[$._v("用这中链表表示，$MAKE-SET$操作和$FIND-SET$操作是非常方便的，只需要$O(1)$的时间。")]),$._v(" "),_("p",[$._v("$MAKE-SET(x)$只需要创建一个只有$x$对象的新的链表。")]),$._v(" "),_("p",[$._v("$FIND-SET(x)$只需沿着$x$对象的返回指针返回到集合对象，然后返回集合对象，然后返回$head$指向对象的成员。")]),$._v(" "),_("p",[$._v("在最坏的情况下，上面给出的$UNION$过程的每次调用平均需要$O(n)$的时间，因为需要把一个较长的表拼接到一个较短的表上，此时必须对较长表的每个成员更新其指向集合对象的指针。现在换一种策略：")]),$._v(" "),_("h3",{attrs:{id:"一种加权合并的启发式策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一种加权合并的启发式策略","aria-hidden":"true"}},[$._v("#")]),$._v(" 一种加权合并的启发式策略")]),$._v(" "),_("p",[$._v("假设每个表中还包含了表的长度，以及拼接次序可以任意，总是把饺短的表拼接到较长的表中。使用这种简单的"),_("strong",[$._v("加权合并启发式策略")]),$._v("，如果两个集合都有$\\Omega(n)$个成员，则单个的$UNION$操作仍然需要$\\Omega(n)$的时间。下面的定理表明，一个具有$m$个$MAKE-SET、UNION、FIND-SET$操作的序列（其中有$n$个是$MAKE-SET$操作）需要耗费$O(m+n\\lg n)$的时间。")]),$._v(" "),_("p",[$._v("证明思路：")]),$._v(" "),_("p",[$._v("因为m个操作至少需要$O(m)$的运行时间，对于每个对象，$MAKE-SET$和$find-set$操作均为$O(1)$时间，关键在于$UNION$的时间。每次合并时，都是将元素个数较少的链表拼接在元素较多的链表后面，因为要更新$x$所在集合的代表对象，所以x所在的集合一定是含有较少元素的链表。对于$x$所在集合元素的个数num,初始num=1,合并后的结果集至少为2，依次类推，当num=2时，合并后的结果集至少为4,...，当合并后的结果集为$n$时，num=$\\lg n$，所以$x$最多被更新$\\lg n$次 。n个对象最多被更新$n\\lg n$次。所以总的操作时间为$O(m+n\\lg n)$")]),$._v(" "),_("h3",{attrs:{id:"不相交集合森林"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不相交集合森林","aria-hidden":"true"}},[$._v("#")]),$._v(" 不相交集合森林")]),$._v(" "),_("p",[$._v("在一个不相交集合的更快实现中，我们使用"),_("strong",[$._v("有根树")]),$._v("来表示集合，树中每个结点包含一个成员（表示连通分量中的一个结点），每棵树代表一个集合。在一个"),_("strong",[$._v("不相交集合森林")]),$._v("中，每个"),_("strong",[$._v("成员仅指向它的父结点")]),$._v("。每棵树的"),_("strong",[$._v("根包含集合的代表")]),$._v("，并且是"),_("strong",[$._v("自己的父结点")]),$._v("。")]),$._v(" "),_("p",[$._v("执行不相交集合的三种操作：")]),$._v(" "),_("p",[$._v("$MAKE-SET$简单的创建一颗只有一个结点的树。")]),$._v(" "),_("p",[$._v("$FIND-SET$操作通过沿着指向父结点的指针找到树的根。这一通向根节点的简单路径上所访问的结点构成了"),_("strong",[$._v("查找路径")]),$._v("。")]),$._v(" "),_("p",[$._v("$UNION$操作使得一棵树的根指向另外一棵树的根。")]),$._v(" "),_("h4",{attrs:{id:"改进运行时间的启发式策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#改进运行时间的启发式策略","aria-hidden":"true"}},[$._v("#")]),$._v(" 改进运行时间的启发式策略")]),$._v(" "),_("p",[$._v("一个包含$n-1$个$UNION$操作的序列可以构造出一颗恰好含有$n$个结点的线性链的树。然而，通过使用"),_("strong",[$._v("两种启发式策略")]),$._v("可以得到一个几乎与总的操作数$m$呈线性关系的运行时间。")]),$._v(" "),_("p",[$._v("启发式策略一："),_("strong",[$._v("按秩合并")]),$._v("（"),_("strong",[$._v("union by rank")]),$._v("）")]),$._v(" "),_("p",[$._v("类似于链表中使用的加权合并启发式策略，使用较少结点的树的根指向具有较多结点的树的根。对于每个结点，维护一个$秩$，它表示该结点高度的一个上界。在使用按秩合并策略的$UNION$操作中，通常将具有较小秩的根指向具有较大秩的根。")]),$._v(" "),_("p",[$._v("启发式策略二："),_("strong",[$._v("路径压缩")]),$._v("（"),_("strong",[$._v("path compression")]),$._v("）。")]),$._v(" "),_("h4",{attrs:{id:"实现不相交集合森林的伪代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现不相交集合森林的伪代码","aria-hidden":"true"}},[$._v("#")]),$._v(" 实现不相交集合森林的伪代码")]),$._v(" "),_("p",[$._v("为了使用按秩合并的启发式策略实现一个不相交集合森林，对于每个结点$x$，维护一个整数值$x.rank$，表示$x$的高度（"),_("strong",[$._v("从$x$到某一后代叶结点的最长简单路径上边的数目")]),$._v("）的一个上界。当$MAKE-SET$创建一个单元素集合时，这个树上的单结点有一个为0的初始秩。每一个$FIND-SET$操作不改变任何秩。$UNION$操作有两种情况，取决于两棵树的根是否具有相同的秩。如果秩不同，较大秩的根成为较小秩的根的父结点，但秩本身保持不变；如果秩相同，任选两个根的一个作为父结点，使它的秩加1。")]),$._v(" "),_("p",[$._v("伪代码：$x.p$表示$x$的父结点，\n$MAKE-SET(X)$\nx.p = x\nx.rank = 0\n$UNION(x,y)$\n$LINK(FIND-SET(x),FIND-SET(y))$\n$LINK(x,y)$\nif x.rank > y.rank\ny.p = x\nelse\nx.p = y\nif x.rank == y.rank\ny.rank = y.rank+1\n//带有"),_("strong",[$._v("路径压缩")]),$._v("的$FIND-SET$过程\n$FIND-SET(x)$\nif x \\neq x.p\nx.p = $FIND-SET(x.p)$\nreturn x.p\n$FIND-SET$过程是一种"),_("strong",[$._v("两趟方法(two-pass method)")]),$._v("，第一趟沿着查找路径向上直到找到根，当递归回溯时，第二趟沿着搜索树向下更新每个结点，使其直接指向根。")]),$._v(" "),_("h4",{attrs:{id:"启发式策略对运行时间的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#启发式策略对运行时间的影响","aria-hidden":"true"}},[$._v("#")]),$._v(" 启发式策略对运行时间的影响")]),$._v(" "),_("p",[$._v("如果"),_("strong",[$._v("单独使用按秩合并或路径压缩")]),$._v("，它们每一个都能"),_("strong",[$._v("改善")]),$._v("不相交集合森林上操作的"),_("strong",[$._v("运行时间")]),$._v("，一起使用，效果更好。")]),$._v(" "),_("h4",{attrs:{id:"带路径压缩的按秩合并的分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#带路径压缩的按秩合并的分析","aria-hidden":"true"}},[$._v("#")]),$._v(" 带路径压缩的按秩合并的分析")]),$._v(" "),_("p",[$._v("按秩合并，总的运行时间为$O(m\\lg n)$，因为总的操作m个，每个对象需要最多$lg n$次，所以总的运行时间为$O(m+nlgn)$，因为m大于n，所以总的运行时间肯定小于$O(m+mlgn)$=$O(mlgn)$")]),$._v(" "),_("p",[$._v("当同时使用"),_("strong",[$._v("按秩合并")]),$._v("和"),_("strong",[$._v("路径压缩")]),$._v("时，最坏情况的运行时间为$O(m\\alpha(n))$，这里的$\\alpha(n)$是一个增长非常慢的函数。在任何一个可以想得到的不相交集合数据结构的应用中，都有$\\alpha(n)\\leq4$，所以我们可以认为在所有实际应用中，其运行时间"),_("strong",[$._v("与$m$呈线性关系")]),$._v("。严格的说是"),_("strong",[$._v("超线性")]),$._v("的。")])])},[],!1,null,null,null);v.default=t.exports}}]);