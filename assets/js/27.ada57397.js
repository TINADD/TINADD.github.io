(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{315:function(n,e,t){"use strict";t.r(e);var h=t(0),c=Object(h.a)({},function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("p",[this._v("class Solution:\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\n#如果head为None 或 head.next为None 返回head 或 k为0，直接返回\nif head is None or head.next is None or k==0:\nreturn head"),e("br"),this._v("\n#先遍历链表，获得链表元素个数\nhc = head\ncount=0\nkc=k\nwhile(hc):\ncount+=1\nhc = hc.next\n#判断旋转几个，因为k有可能大于链表元素个数，这时候要对k取余\nkc = kc %count\n#如果kc等于0，不需要变换指针，返回head\nif kc==0:\nreturn head\n#遍历链表，将第count-kc个元素的next 指向nullptr，将尾元素的next指向head，将head指向第count-kc+1个元素\nhc = head\nnewhead = head\nheadc = head\ncountc = 0\nwhile hc.next:\ncountc+=1\nif countc == count-kc:\nnewhead = hc.next\nhead = hc.next\nhc.next = None\nbreak\nhc = hc.next\nwhile head.next:\nhead = head.next\nhead.next = headc\nreturn newhead")])])},[],!1,null,null,null);e.default=c.exports}}]);