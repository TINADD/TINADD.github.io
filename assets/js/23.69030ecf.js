(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{285:function(n,e,o){"use strict";o.r(e);var r=o(0),t=Object(r.a)({},function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nvector<Node*> neighbors;")]),n._v(" "),o("pre",[o("code",[n._v("   Node() {}\n   \n   Node(int _val, vector<Node*> _neighbors) {\n       val = _val;\n       neighbors = _neighbors;\n   }\n")])]),n._v(" "),o("p",[n._v("};\n*/\nclass Solution {\npublic:\n//递归调用函数，为了避免重复开辟空间，将已经访问过的结点记录下来。\nmap<Node "),o("em",[n._v(",Node "),o("em",[n._v("> has;\nNode")]),n._v(" cloneGraph(Node")]),n._v(" node) {\nif(node == nullptr) return nullptr;\nif(has.find(node) != has.end()) return has[node]; //结点已经存在了\nNode *head = new Node();\nhead->val = node->val;\nhas[node] = head;//访问的是原图，保存的是新开辟的图\nfor(int i=0;i"),o("node-",[n._v("neighbors.size();++i)\n{\nhead->neighbors.push_back(cloneGraph(node->neighbors[i]));\n}\nreturn head;\n}")])],1),n._v(" "),o("p",[n._v("};")])])},[],!1,null,null,null);e.default=t.exports}}]);