(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{280:function(t,v,_){"use strict";_.r(v);var i=_(0),e=Object(i.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"git"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#git","aria-hidden":"true"}},[t._v("#")]),t._v(" Git")]),t._v(" "),_("h2",{attrs:{id:"git基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#git基础","aria-hidden":"true"}},[t._v("#")]),t._v(" Git基础")]),t._v(" "),_("h3",{attrs:{id:"取得项目的-git-仓库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#取得项目的-git-仓库","aria-hidden":"true"}},[t._v("#")]),t._v(" "),_("strong",[t._v("取得项目的 Git 仓库")])]),t._v(" "),_("p",[t._v("第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。即到此项目所在的目录，执行:")]),t._v(" "),_("p",[_("strong",[t._v("git init")])]),t._v(" "),_("p",[t._v("初始化后，在当前目录下会出现一个名为 "),_("strong",[t._v(".git")]),t._v(" 的目录，所有 Git 需要的数据和资源都存放在这个目录中。")]),t._v(" "),_("p",[t._v("如果当前目录下有几个文件想要纳入"),_("strong",[t._v("版本控制")]),t._v("，需要先用 "),_("code",[t._v("git add")]),t._v("命令告诉 Git 开始对这些文件进行跟踪，然后"),_("strong",[t._v("git commit")]),t._v(" 提交：")]),t._v(" "),_("p",[t._v("*"),_("em",[t._v("git add  "),_("em",[t._v(".c")])]),t._v(" "),_("strong",[t._v("git add README")]),t._v(" "),_("strong",[t._v("git commit -m 'initial project version'")])]),t._v(" "),_("p",[t._v("第二种是通过**git clone [url]**从已有的 Git 仓库克隆出一个新的镜像仓库来。执行：")]),t._v(" "),_("p",[_("strong",[t._v("git clone git://github.com/schacon/grit.git")])]),t._v(" "),_("p",[t._v("如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：")]),t._v(" "),_("p",[_("strong",[t._v("git clone git://github.com/schacon/grit.git  mygrit")])]),t._v(" "),_("p",[t._v("OK，现在新建的目录变成了mygrit。")]),t._v(" "),_("h3",{attrs:{id:"记录每次更新到仓库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#记录每次更新到仓库","aria-hidden":"true"}},[t._v("#")]),t._v(" "),_("strong",[t._v("记录每次更新到仓库")])]),t._v(" "),_("p",[t._v("检查当前文件状态")]),t._v(" "),_("p",[_("strong",[t._v("$ git status")])]),t._v(" "),_("p",[_("strong",[t._v("状态简览")])]),t._v(" "),_("p",[_("code",[t._v("git status")]),t._v(" 命令的输出十分详细，但其用语有些繁琐。 如果你使用 "),_("code",[t._v("git status -s")]),t._v(" 命令或 "),_("code",[t._v("git status --short")]),t._v(" 命令，你将得到一种更为紧凑的格式输出。 运行 "),_("code",[t._v("git status -s")]),t._v(" ，状态报告输出如下：")]),t._v(" "),_("p",[t._v("$ git status -s\nM README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 "),_("code",[t._v("git diff")]),t._v("：此命令比较的是工作目录中"),_("strong",[t._v("当前文件")]),t._v("和"),_("strong",[t._v("暂存区域快照")]),t._v("之间的差异，也就是修改之后还没有暂存起来的变化内容。")]),t._v(" "),_("p",[t._v("若要查看已暂存的将要添加到下次提交里的内容，可以用 "),_("code",[t._v("git diff --cached")]),t._v(" 命令。（Git 1.6.1 及更高版本还允许使用 "),_("code",[t._v("git diff --staged")]),t._v("，效果是相同的，但更好记些。）")]),t._v(" "),_("p",[t._v("$ git diff --staged")]),t._v(" "),_("p",[_("strong",[t._v("note:  git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。")]),t._v(" "),_("strong",[t._v("所以有时候你一下子暂存了所有更新过的文件后，运行 "),_("code",[t._v("git diff")]),t._v(" 后却什么也没有，就是这个原因。")])]),t._v(" "),_("p",[_("strong",[t._v("提交更新")])]),t._v(" "),_("p",[t._v("$ git commit")]),t._v(" "),_("p",[_("strong",[t._v("跳过使用暂存区域")]),t._v("(在提交的时候，给 "),_("code",[t._v("git commit")]),t._v(" 加上 "),_("code",[t._v("-a")]),t._v(" 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 "),_("code",[t._v("git add")]),t._v(" 步骤)")]),t._v(" "),_("p",[t._v("$ git commit -a -m 'added new benchmarks'")]),t._v(" "),_("p",[_("strong",[t._v("移除文件")]),t._v("要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 "),_("code",[t._v("git rm")]),t._v(" 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。如果只是简单地从工作目录中手工删除文件($ rm PROJECTS.md)，运行 "),_("code",[t._v("git status")]),t._v(" 时就会在 “Changes not staged for commit” 部分（也就是 "),_("em",[t._v("未暂存清单")]),t._v("）看到：")]),t._v(" "),_("p",[t._v("如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 "),_("code",[t._v("-f")]),t._v("（译注：即 force 的首字母）")]),t._v(" "),_("p",[t._v("如果你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。比如当你忘记添加 "),_("code",[t._v(".gitignore")]),t._v(" 文件，不小心把一个很大的日志文件或一堆 "),_("code",[t._v(".a")]),t._v(" 这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用 "),_("code",[t._v("--cached")]),t._v(" 选项：")]),t._v(" "),_("p",[t._v("$ git rm --cached README")]),t._v(" "),_("p",[_("strong",[t._v("文件重命名")])]),t._v(" "),_("p",[t._v("$ git mv file_from file_to")]),t._v(" "),_("p",[t._v("其实，运行 "),_("code",[t._v("git mv")]),t._v(" 就相当于运行了下面三条命令：")]),t._v(" "),_("p",[t._v("mv README.md README\n​git rm README.md\ngit add README")]),t._v(" "),_("h3",{attrs:{id:"查看提交历史"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查看提交历史","aria-hidden":"true"}},[t._v("#")]),t._v(" 查看提交历史")]),t._v(" "),_("p",[t._v("$ git log")]),t._v(" "),_("p",[t._v("默认不用任何参数的话，"),_("code",[t._v("git log")]),t._v(" 会按提交时间列出所有的更新，最近的更新排在最上面。")]),t._v(" "),_("p",[_("code",[t._v("git log")]),t._v(" 有许多选项可以帮助你搜寻你所要找的提交，一个常用的选项是 "),_("code",[t._v("-p")]),t._v("，用来显示每次提交的内容差异。\n你也可以加上 "),_("code",[t._v("-2")]),t._v(" 来仅显示最近两次提交：")]),t._v(" "),_("p",[t._v("$ git log -p -2")]),t._v(" "),_("p",[t._v("你也可以为 "),_("code",[t._v("git log")]),t._v(" 附带一系列的总结性选项。\n比如说，如果你想看到每次提交的简略的统计信息，你可以使用 "),_("code",[t._v("--stat")]),t._v(" 选项：")]),t._v(" "),_("p",[t._v("$ git log --stat")]),t._v(" "),_("p",[_("code",[t._v("--stat")]),t._v(" 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。")]),t._v(" "),_("h3",{attrs:{id:"撤销操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#撤销操作","aria-hidden":"true"}},[t._v("#")]),t._v(" 撤销操作")])])},[],!1,null,null,null);v.default=e.exports}}]);