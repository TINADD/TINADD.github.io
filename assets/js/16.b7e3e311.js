(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{308:function(v,_,r){"use strict";r.r(_);var t=r(0),n=Object(t.a)({},function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h1",{attrs:{id:"第一节课"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一节课","aria-hidden":"true"}},[v._v("#")]),v._v(" 第一节课")]),v._v(" "),r("h2",{attrs:{id:"图相关知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图相关知识","aria-hidden":"true"}},[v._v("#")]),v._v(" 图相关知识")]),v._v(" "),r("p",[v._v("G=(V,E)，V为顶点集，E为边集。设图有n个顶点，V={v1,v2,v3,......,vn}")]),v._v(" "),r("h3",{attrs:{id:"_1、图的基本术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、图的基本术语","aria-hidden":"true"}},[v._v("#")]),v._v(" 1、图的基本术语")]),v._v(" "),r("p",[r("strong",[v._v("有向图")]),v._v("：**<v,w>"),r("strong",[v._v("属于E，表示从弧尾v到弧头w的一条弧。\n"),r("strong",[v._v("无向图")]),v._v("：边")]),v._v("(v,w)**属于E，\n"),r("strong",[v._v("混合图")]),v._v("：既有有向边，又有无向边的图\n"),r("strong",[v._v("简单无向图")]),v._v("：（"),r("strong",[v._v("不存在顶点到自身的边")]),v._v(" （自环），且任意两个不同的顶点之间没有平行的两条边）；")]),v._v(" "),r("p",[r("strong",[v._v("简单有向图")]),v._v("：（"),r("strong",[v._v("不存在顶点到自身的弧")]),v._v("，且任意两个不同的顶点之间没有同方向\n的两条弧）。简单无向图和简单有向图统称为"),r("strong",[v._v("简单图")]),v._v("。\n"),r("strong",[v._v("邻接、依附或关联")]),v._v("：若无向图有边(v,w)，则称顶点v和w"),r("strong",[v._v("相邻或邻接")]),v._v("，称(v,w)依附点v和w，或称与边(v,w)相关联的\n两个顶点是v和w；有向图若有弧<v,w>，则称顶点v"),r("strong",[v._v("邻接到")]),v._v("w，w"),r("strong",[v._v("邻接自")]),v._v("v，弧<v,w>依附顶点v和w，或称与弧<v,w>相关联的两个顶点是v和w。通常称"),r("strong",[v._v("w是v的邻接点")]),v._v(" "),r("strong",[v._v("无向完全图")]),v._v("：对简单无向图，图中任意两个不同的顶点间都有边。有"),r("strong",[v._v("n个顶点")]),v._v("的无向完全图有"),r("strong",[v._v("n(n-1)/2条边")]),v._v(" "),r("strong",[v._v("有向完全图")]),v._v("：对简单有向图，任意两个顶点间都有方向互为相反的两条弧。有"),r("strong",[v._v("n个顶点")]),v._v("的有向完全图有"),r("strong",[v._v("n(n-1)条弧")]),v._v(" "),r("strong",[v._v("网或赋权图")]),v._v("：无向图或有向图的边或弧上带有一个表示某种物理量的权值\n"),r("strong",[v._v("稀疏图、稠密图")]),v._v("：边或弧数很少(多)的无向图或有向图\n顶点的"),r("strong",[v._v("度、入度、出度")]),v._v("：无向图中任意顶点v，"),r("strong",[v._v("与v相关联的边数称为v的度")]),v._v("，Degree(v)，简记D(v)，有n个顶点和e条边的无向图，所有"),r("strong",[v._v("顶点的度之和")]),v._v("是"),r("strong",[v._v("边总数的2倍")]),v._v("；有向图中，以顶点v为弧尾的弧的数目称为v的出度，OD(v)，以v为弧头的的弧的数目称为v的入度，ID(v)，"),r("strong",[v._v("D(v)=ID(v)+OD(v)为v的度")]),v._v("。有n个顶点e条弧的有\n向图，所有"),r("strong",[v._v("顶点的入度之和等于出度之和等于边总数e")]),v._v("。\n"),r("strong",[v._v("子图")]),v._v("：G=(V,E),G'=(V',E')，若V'是V的（真）子集，E'是E的（真）子集，且"),r("strong",[v._v("E'中的边仅与V'中的顶点相关联")]),v._v("，则G'是G的（真）子图。\n"),r("strong",[v._v("路径、简单路径、回路")]),v._v("：无（有）向图G=(V,E)，若有顶点序列$v_s,v_{i1},v_{i2},v_{i3},...,v_{ik},v_k$，且边$(v_{ij}-1,v_{ij})（弧<v_{ij}-1,v_{ij}>）$属于E，称$v_s$到$v_k$存在路径$v_{i1},v_{i2},v_{i3},...,v_{ik}$。若$v_s$到  $v_k$路\n径上顶点除顶点$v_s$和$v_k$可以相同外，其他顶点都不同，上述路径为"),r("strong",[v._v("简单路径")]),v._v("。若$v_s$=$v_k$，则称为"),r("strong",[v._v("回路")]),v._v("。\n"),r("strong",[v._v("连通和可达")]),v._v("："),r("strong",[v._v("有向图")]),v._v("中顶点"),r("strong",[v._v("v到w")]),v._v("有路径称"),r("strong",[v._v("v到w是可达的")]),v._v("。"),r("strong",[v._v("无向图")]),v._v("v到w有路径称v和w是"),r("strong",[v._v("连通的")]),v._v(" "),r("strong",[v._v("连通图和强连通图")]),v._v("："),r("strong",[v._v("无向图中任意两个不同顶点")]),v._v("都是"),r("strong",[v._v("连通的称它为连通图")]),v._v("，否则为非连通图。有向图中"),r("strong",[v._v("任意两个不同顶点都是可达的")]),v._v("称之为"),r("strong",[v._v("强连通图")]),v._v("或简称"),r("strong",[v._v("连通图")]),v._v("，否则为非强连通图或非连通图\n"),r("strong",[v._v("连通分量和强连通分量")]),v._v("：无向图的"),r("strong",[v._v("极大连通子图")]),v._v("称为"),r("strong",[v._v("连通分量")]),v._v("；有向图的"),r("strong",[v._v("极大强连通子图")]),v._v("称为"),r("strong",[v._v("强连通分量")]),v._v("或连通分量。极大指该"),r("strong",[v._v("子图包括了所有连通的顶点")]),v._v("以及这些"),r("strong",[v._v("顶点相关联的所有边")]),v._v("。\n"),r("strong",[v._v("树和有向树")]),v._v("："),r("strong",[v._v("连通且无回路的的无向图")]),v._v("称为无向树，简称树。含n个顶点的树有n-1条边。在忽略弧方向后，连通且无回路的有向树称为有向树。含n个顶点的有向树有n-1条弧。实际中指的"),r("strong",[v._v("有向树")]),v._v("在选定一个顶点作为根节点后，"),r("strong",[v._v("弧的方向都与从根节点指向叶结点的方向一致或全部相反")]),v._v("。\n"),r("strong",[v._v("生成树、生成森林")]),v._v("：由"),r("strong",[v._v("n个顶点构成的连通无向图")]),v._v("的任何一个含n个顶点的"),r("strong",[v._v("极小连通子图")]),v._v("称为该图的生成树。对于非连通无向图，由"),r("strong",[v._v("连通子图可得到生成子树")]),v._v("，非连通无向图的所有连通分量得到的生成子树构成该树的生成森林。\n"),r("strong",[v._v("极大连通子图：")])]),v._v(" "),r("p",[v._v("1.连通图只有一个极大连通子图，就是它本身。（是唯一的）\n2.非连通图有多个极大连通子图。（非连通图的极大连通子图叫做连通分量，每个分量都是一个连通图）\n3."),r("strong",[v._v("称为极大是因为如果此时加入任何一个不在图的点集中的点都会导致它不再连通。")])]),v._v(" "),r("p",[r("strong",[v._v("极小连通子图：")]),v._v("\n1.一个连通图的"),r("strong",[v._v("生成树")]),v._v("是该连通图的的"),r("strong",[v._v("极小连通子图")]),v._v("。（同一个连通图可以有不同的生成树，所以生成树不是唯一的）（"),r("strong",[v._v("极小连通子图只存在于连通图中")]),v._v("）\n2.用边把极小连通子图中所有节点给连起来，若有n个节点，则有n-1条边。\n3.之所以称为极小是因为此时如果删除一条边，就无法构成生成树，也就是说给极小连通子图的每个边都不可少。")]),v._v(" "),r("p",[v._v("4.如果在生成树上添加一条边，一定会构成一个环。\n也就是说"),r("strong",[v._v("只要能连通图的所有顶点而又不产生回路的任何子图都是它的生成树。")])]),v._v(" "),r("h3",{attrs:{id:"_2、图的基本算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、图的基本算法","aria-hidden":"true"}},[v._v("#")]),v._v(" 2、图的基本算法")]),v._v(" "),r("h4",{attrs:{id:"广度优先搜索"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索","aria-hidden":"true"}},[v._v("#")]),v._v(" 广度优先搜索")]),v._v(" "),r("p",[r("strong",[v._v("广度优先搜索")]),v._v("是最简单的搜索算法之一。给定图$G=(V,E)$和一个可识别的源结点$s$，该算法能够计算"),r("strong",[v._v("从源结点")]),v._v("$s$到每个"),r("strong",[v._v("可到达的结点")]),v._v("的"),r("strong",[v._v("距离")]),v._v("（最少的边数），同时生成一颗”"),r("strong",[v._v("广度优先搜索树")]),v._v("“。")]),v._v(" "),r("p",[v._v("广度优先搜索之所以如此得名是因为该算法始终是将"),r("strong",[v._v("已发现结点")]),v._v("和"),r("strong",[v._v("未发现结点")]),v._v("之间的边界沿其"),r("strong",[v._v("广度方向")]),v._v("向外扩展。算法需要在发现所有"),r("strong",[v._v("距离源结点$s$为$k$的所有结点")]),v._v("之后，才会发现距离源结点$s$为$k+1$的其他结点。")]),v._v(" "),r("p",[v._v("在执行广度优先搜索的过程中将"),r("strong",[v._v("构造出一棵广度优先树")]),v._v("。")]),v._v(" "),r("h4",{attrs:{id:"深度优先搜索"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索","aria-hidden":"true"}},[v._v("#")]),v._v(" 深度优先搜索")]),v._v(" "),r("p",[v._v("深度优先搜索总是对最近才发现的结点$v$的出发边进行探索，直到该结点的所有出发边都被发现为止。一旦结点$v$的所有出发边都被发现，搜索则”回溯“到$v$的前驱结点，来搜索该前驱结点的出发边，该过程一直持续到从源结点可以到达的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点。")]),v._v(" "),r("h4",{attrs:{id:"拓扑排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拓扑排序","aria-hidden":"true"}},[v._v("#")]),v._v(" 拓扑排序")]),v._v(" "),r("p",[v._v("对于一个"),r("strong",[v._v("有向无环图")]),v._v("$G=(V,E)$，其"),r("strong",[v._v("拓扑排序")]),v._v("是$G$中所有结点的一种线性次序，该次序满足如下条件：如果图$G$包含边$(u,v)$，则结点$u$在拓扑排序中处于结点$v$的前面（如果图$G$包含环路，则不可能排出一个线性次序）。"),r("u",[r("strong",[v._v("可以将图的拓扑排序看做是将图的所有结点在一条水平线上排开。")])])]),v._v(" "),r("p",[v._v("以下两种最小生成树算法都是贪心算法，贪心算法的每一步都必须在多个可能的选择中选择一个，贪心算法每次都选择当前看来最好的。")]),v._v(" "),r("p",[v._v("通用的"),r("strong",[v._v("生成树算法思想")]),v._v("：")]),v._v(" "),r("p",[v._v("GENERIC-MST(G,w) //G为连通无向图，w是边的权重函数\nA = $\\empty$"),r("br"),v._v("\nwhile A does not form a spanning tree\nfind a edge(u,v) that is safe for A\nA = A ∪{(u,v)}\nreturn A")]),v._v(" "),r("p",[v._v("一些定义：")]),v._v(" "),r("p",[v._v("无向图$G=(V,E)$的一个切割$(S,V-S)$是集合"),r("strong",[v._v("V的一个划分")]),v._v("，如果一条边(u,v)∈E的"),r("strong",[v._v("一个端点位于集合S")]),v._v("，"),r("strong",[v._v("另一个端点位于集合V-S")]),v._v("，则称该条边"),r("strong",[v._v("横跨")]),v._v("切割。$(S,V-S)$如果A中不存在横跨该切割的边，则称该切割"),r("strong",[v._v("尊重")]),v._v("集合A。在横跨一个切割的所有边中，权重最小的边称为"),r("strong",[v._v("轻量级边")]),v._v("。")]),v._v(" "),r("p",[v._v("用来确认安全边的规则：")]),v._v(" "),r("p",[r("strong",[v._v("定理23.1")]),v._v("  设$G=(V,E)$是一个在边$E$上定义了实数值权重函数$w$的连通无向图。设集合$A为E$的一个子集，且A包括在图$G$某棵最小生成树中，设$(S,V-S)$为图G中尊重集合A的任意一个切割，又设$(u,v)$是横跨切割$(S,V-S)$的一条轻量级边。那么边$(u,v)$于集合A是安全的。")]),v._v(" "),r("p",[v._v("以下两种算法都是通用算法的细化，不同之处在于找到安全边的方法不同。")]),v._v(" "),r("h4",{attrs:{id:"最小生成树算法-prim"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树算法-prim","aria-hidden":"true"}},[v._v("#")]),v._v(" 最小生成树算法-Prim")]),v._v(" "),r("p",[v._v("在$Prim$算法中，集合A则是一颗树，每次加入到A中的安全边永远是"),r("strong",[v._v("连接A和A之外某个结点的边中权重最小的边。")])]),v._v(" "),r("p",[v._v("$Prim$算法的一个性质是集合$A$中的边总是构成一棵树。这颗树从任意一个根结点$r$开始，一直长大到覆盖$V$中所有结点。")]),v._v(" "),r("p",[v._v("为了有效地实现$Prim$算法，需要一种"),r("strong",[v._v("快速的方法")]),v._v("来"),r("strong",[v._v("选择一条新的边")]),v._v("。在算法的执行过程中，所有不在树$A$中的结点都存放在一个基于$key$属性的最小优先队列$Q$中。对于每个结点，$v.key$保存的是连接$v$和树中结点的所有边中最小边的权重。$v.\\pi$表示结点$v$在树中的父结点。$Prim$算法将$GENERIC-MST$中的集合A维持在$A = {(v,v.\\pi):v∈V-{r}-Q}$的状态下。")]),v._v(" "),r("p",[v._v("当$Prim$算法终止时，最小优先队列$Q$将为空，而$G$的最小生成树$A$则是：$A ={(v,v.\\pi):v∈V-{r } }$")]),v._v(" "),r("p",[v._v("$MST-PRIM(G,w,r)$\nfor each u∈G.V\nu.key = $\\infty$\nu.$\\pi$ = NIL\nr.key = 0\nQ = G.V\nwhile Q $\\neq \\empty$\nu = $EXTRACT-MIN(Q)$\nfor each v $\\in$ G.adj[u]  //每次确定一个要加入A中的结点后，就更新其与Q中相邻结点的属性信息 （$\\pi key$）\nif v$\\in Q$ and $w(u,v)<v.key$\nv.$\\pi$ = u\nv.key = w(u,v)")]),v._v(" "),r("p",[v._v("$Prim$算法的运行时间取决于"),r("strong",[v._v("最小优先队列")]),v._v("$Q$的实现方式。可以将$Q$实现为"),r("strong",[v._v("二叉最小优先队列")]),v._v("。从渐近意义上来说，$Prim$算法和$Kruskal$算法的运行时间相同。如果使用斐波那契堆来实现最小优先队列$Q$，$Prim$算法的渐近运行时间可以得到进一步改善。")]),v._v(" "),r("h4",{attrs:{id:"最小生成树算法-kruskal"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树算法-kruskal","aria-hidden":"true"}},[v._v("#")]),v._v(" 最小生成树算法-Kruskal")]),v._v(" "),r("p",[v._v("在$Kruskal$算法中，集合A是一个森林，结点就是给定图的结点。每次加入到集合A中的安全边永远是"),r("strong",[v._v("权重最小的连接两个不同分量的边")]),v._v("。按边的权重，从小到大依次判断。")]),v._v(" "),r("p",[v._v("这里使用一个"),r("strong",[v._v("不相交的集合数据结构")]),v._v("来维护几个互不相交的元素集合。所以，算法的运行时间依赖于不相交集合数据结构的实现方式。使用"),r("strong",[v._v("不相交集合森林")]),v._v("实现，并增加"),r("strong",[v._v("按秩合并")]),v._v("和"),r("strong",[v._v("路径压缩")]),v._v("的功能，克鲁斯卡尔算法的运行时间为$O(ElgV)$")]),v._v(" "),r("p",[r("a",{attrs:{href:"不相交的集合数据结构.md"}},[v._v("不相交的集合数据结构")])]),v._v(" "),r("p",[v._v("$MST-KRUSKAL(G,w)$\nA = $\\empty$\n//每个集合都代表森林中的一颗树，初始化为一个结点就是一颗树\nfor each vertex v ∈G.V\nMAKE-SET(v)"),r("br"),v._v("\nsort the edge of G.E into nondecreasing order by weight w\nfor each edge(u,v)∈G.E,taken in nondecreasing order by weight\n//FIND-SET(v)返回元素v所在的连通分量的代表元素\nif FIND-SET(u) \\neq FIND-SET(v) //如果u和v不在同一颗树\nA = A∪{(u,v)}\nUNION(u,v) //合并结点u和结点v所在的树\nreturn A")]),v._v(" "),r("h4",{attrs:{id:"单源最短路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单源最短路径","aria-hidden":"true"}},[v._v("#")]),v._v(" 单源最短路径")]),v._v(" "),r("p",[v._v("在"),r("strong",[v._v("最短路径问题")]),v._v("中，我们给定一个"),r("strong",[v._v("带权重的有向图")]),v._v("$G=(V,E)$和"),r("strong",[v._v("权重函数")]),v._v("$w:E\\to R$，该权重函数将每条边映射到实数值的权重上。图中一条路径$p=<v_0,v_1,...,v_k>$的权重$w(p)$是构成该路径的所有边的权重之和。")]),v._v(" "),r("h5",{attrs:{id:"最短路径的几个变体"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最短路径的几个变体","aria-hidden":"true"}},[v._v("#")]),v._v(" 最短路径的几个变体")]),v._v(" "),r("p",[v._v("单源最短路径问题：给定一个图$G=(V,E)$，找到给定源结点$s∈V$到每个结点$v∈V$的最短路径。")]),v._v(" "),r("p",[r("strong",[v._v("单目的地最短路径问题")]),v._v("：找到每个结点$v$到给定目的地结点$t$的最短路径。如果将图的每条边的方向翻转过来，就转化为单源最短路径问题。")]),v._v(" "),r("p",[r("strong",[v._v("单结点对最短路径问题")]),v._v("：找到从给定结点$u$到给定结点$v$的最短路径。解决了结点$u$的单源最短路径问题，也就解决了该问题。")]),v._v(" "),r("p",[v._v("ps.在该问题的所有已知算法中，最坏情况下的渐近运行时间都和最好的单源最短路径算法的运行时间一样。")]),v._v(" "),r("p",[r("strong",[v._v("所有节点对最短路径问题")]),v._v("：虽然可以针对每个结点运行一遍单源最短路径算法，通常可以更快的解决这个问题。")]),v._v(" "),r("p",[r("strong",[v._v("最短路径的最优子结构")]),v._v("：")]),v._v(" "),r("p",[v._v("最短路径算法通常依赖"),r("strong",[v._v("最短路径")]),v._v("的一个"),r("strong",[v._v("重要性质")]),v._v("："),r("strong",[v._v("两个结点之间的一条最短路径包含其他最短路径。")])]),v._v(" "),r("p",[v._v("即"),r("strong",[v._v("最短路径的子路径也是一条最短路径")]),v._v("。")]),v._v(" "),r("p",[r("strong",[v._v("负权重的边")]),v._v("：如果从结点$s$到结点$v$的某条路径上存在权重为负值的环路，我们定义$\\theta(s,v) = - \\infty$ ，即$s\\to v$的最短路径权重没有定义。")]),v._v(" "),r("p",[r("strong",[v._v("环路")]),v._v("： 一条最短路径不可能包含环路。因为如果包含权重为负的环路就不能找到一条最短路径了（多走一个环路权重值就会更小）；如果包含一个权重为正的环路，该最短路径就不是最短路径（减去该环路权重值就会变得更小）。")]),v._v(" "),r("p",[v._v("因此，"),r("strong",[v._v("我们可以假设找到的最短路径中没有环路")]),v._v("，都是简单路径。即最短路径最多包含$|V|-1$条边。")]),v._v(" "),r("p",[r("strong",[v._v("松弛操作")])]),v._v(" "),r("p",[v._v("本章的算法需要使用"),r("strong",[v._v("松弛")]),v._v("技术。每个结点$v$维持一个属性$v.d$，记录从源结点$s$到$v$的最短路径权重的上界。$v.d$为$s$到$v$的最"),r("strong",[v._v("短路径估计")]),v._v("。\n//先对每个结点进行初始化\n$INITIALIZE-SINGLE-SOURCE(G,s)$\nfor each vertex $v \\in G.V$\n$v.d = \\infty $\n$v.\\pi = NIL$\ns.d = 0\n对边$(u,v)$的松弛过程：首先测试一下是否可以对从$s$到$v$的最短路径进行改善。\n//下面是对边$(u,v)$在$O(1)$时间内进行的松弛操作\n$RELAX(u,v,w)$\nif v.d > u.d+w(u,v)\nv.d = u.d+w(u,v)\n$v.\\pi = u$")]),v._v(" "),r("p",[r("strong",[v._v("松弛")]),v._v("是唯一导致"),r("strong",[v._v("最短路径估计")]),v._v("和"),r("strong",[v._v("前驱结点")]),v._v("发生变化的操作。")]),v._v(" "),r("p",[v._v("这里讨论的每个最短路径算法都将调用$INITIALIZE-SINGLE-SOURCE$，重复对边进行松弛。下面所讨论的算法之间的不同之处是对每条边进行"),r("strong",[v._v("松弛的次数")]),v._v("和"),r("strong",[v._v("松弛边的次序")]),v._v("有所不同。")]),v._v(" "),r("p",[v._v("$Dijkstra$算法对每条边仅松弛一次。Bellman-Ford算法对每条边松弛$|V|-1$次。")]),v._v(" "),r("h5",{attrs:{id:"最短路径之-bellman-ford-算法权重为"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最短路径之-bellman-ford-算法权重为","aria-hidden":"true"}},[v._v("#")]),v._v(" 最短路径之$Bellman-Ford$算法权重为")]),v._v(" "),r("p",[v._v("$Bellman-Ford$算法解决的是一般情况下的单源最短路径问题，边的权重值可以为负值。该算法返回一个"),r("strong",[v._v("布尔值")]),v._v("以"),r("strong",[v._v("表明")]),v._v("是否存在一个从"),r("strong",[v._v("源结点可以到达的权重为负的环路")]),v._v("。"),r("strong",[v._v("如果存在")]),v._v("这样一个环路，算法将告诉我们不存在解决方案，"),r("strong",[v._v("如果没有这种环路存在")]),v._v("，算法将给出最短路径和它们的权重。")]),v._v(" "),r("p",[v._v("$Bellman-Ford$算法通过对边进行松弛操作来渐近地降低从源结点到每个结点$v$的最短路径的估计值$v.d$，直到该估计值等于实际的的最短路径权重$\\delta(s,v)$相同时为止。该算法返回TRUE当且仅当输入图不包含可以从源结点到达的权重为负值的环路。\n时间复杂度为$O(VE)$\n$BELLMAN-FORD(G,w,s)$\nINITIALIZE-SINGLE-SOURCE(G,s)\nfor i =1 to |G.V|-1\nfor each edge$(u,v) \\in G.E$\nRELAX(u,v,w)\nfor each edge$(u,v) \\in G.E$\nif v.d > u.d+w(u,v)\nreturn FALSE\nreturn TRUE")]),v._v(" "),r("h5",{attrs:{id:"有向无环图中的单源最短路径问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有向无环图中的单源最短路径问题","aria-hidden":"true"}},[v._v("#")]),v._v(" 有向无环图中的单源最短路径问题")]),v._v(" "),r("p",[v._v("根据")]),v._v(" "),r("h1",{attrs:{id:"第二节课"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二节课","aria-hidden":"true"}},[v._v("#")]),v._v(" 第二节课")]),v._v(" "),r("h2",{attrs:{id:"_26-最大流问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_26-最大流问题","aria-hidden":"true"}},[v._v("#")]),v._v(" 26.最大流问题")]),v._v(" "),r("p",[v._v("...")]),v._v(" "),r("h3",{attrs:{id:"_26-3最大二分匹配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_26-3最大二分匹配","aria-hidden":"true"}},[v._v("#")]),v._v(" 26.3最大二分匹配")]),v._v(" "),r("p",[r("strong",[v._v("二分图")]),v._v("：流网络$G=(V,E)$的一个切割$(S,T)$将结点集合$V$划分为$S$和$T=V-S$两个集合。$\\forall (u,v) \\in E,u \\in S,v \\in T$，图$G$是二分图。")]),v._v(" "),r("p",[r("strong",[v._v("匹配")]),v._v("：给定一个无向图$G=(V,E)$，一个"),r("strong",[v._v("匹配")]),v._v("是边的一个子集$M\\subseteq E$，使得对于所有结点$v \\in V$，子集$M$中最多有一条边与结点$v$相连。如果子集$M$中的某条边与结点$v$相连，则称结点$v$由$M$"),r("strong",[v._v("匹配")])]),v._v(" "),r("p",[v._v("否则结点$v$就"),r("strong",[v._v("没有匹配")]),v._v("的。")]),v._v(" "),r("p",[r("strong",[v._v("最大匹配")]),v._v("：最大基的匹配。对于任意的匹配$M',|M|\\ge|M'|$的匹配$M$。")]),v._v(" "),r("h2",{attrs:{id:"_35-近似算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_35-近似算法","aria-hidden":"true"}},[v._v("#")]),v._v(" 35.近似算法")]),v._v(" "),r("p",[r("strong",[v._v("近似算法")]),v._v("：对于问题的任何一个实例，都可以证明所设计的算法与最优解的差距（"),r("strong",[v._v("近似比")]),v._v("）。")]),v._v(" "),r("h3",{attrs:{id:"图顶点覆盖问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图顶点覆盖问题","aria-hidden":"true"}},[v._v("#")]),v._v(" 图顶点覆盖问题")]),v._v(" "),r("p",[r("strong",[v._v("顶点覆盖")]),v._v("：对于无向无权简单图$G=(V,E)$的"),r("strong",[v._v("顶点覆盖")]),v._v("是一个子集$V'\\subseteq V$，满足如果有$(u,v)\\in E,则u\\in V'或v \\in V'(或者同时成立)$。即每个顶点**’覆盖‘"),r("strong",[v._v("其相关联的边，并且$G$的顶点覆盖是覆盖$E$中所有边的顶点所组成的集合。顶点覆盖的")]),v._v("规模"),r("strong",[v._v("是指它所包含的")]),v._v("顶点数**。")]),v._v(" "),r("p",[r("strong",[v._v("顶点覆盖问题")]),v._v("：在一个给定的图中，找出具有"),r("strong",[v._v("最小规模的顶点覆盖")]),v._v("（"),r("strong",[v._v("最优顶点覆盖")]),v._v("）。")]),v._v(" "),r("h4",{attrs:{id:"策略一贪心算法："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#策略一贪心算法：","aria-hidden":"true"}},[v._v("#")]),v._v(" 策略一贪心算法：")]),v._v(" "),r("p",[v._v("依次找到度数最大的顶点，删除与该顶点有关所有的边，直到所有的边都被删除。")]),v._v(" "),r("p",[r("strong",[v._v("问题")]),v._v("：贪心算法找到的不一定是最优解，怎么证明？")]),v._v(" "),r("p",[v._v("找一个反例：")]),v._v(" "),r("p",[v._v("找一个与最优解差别较大的反例")])])},[],!1,null,null,null);_.default=n.exports}}]);